약관 관리 페이지

약관은 관리할 수 있는 페이지
- 회원가입시 체크할 약관의 내용을 수정, 추가하는 페이지 구축
- 약관을 변경한다면 기존약관에 동의한 유저들이 로그인 했을때 새로운 약관 동의 모달창을 만듬
- 약관에 동의 하지 않는다면 다음버튼 또는 플렛폼을 이용할 수 없도록 조치


약관을 저장하는 데이터베이스 구축
term_id (PK): 약관 고유 ID
type: 약관 종류 (예: 'TERMS', 'PRIVACY', 'MARKETING')
version: 버전 (예: '1.0', '1.1', '20251105')
content: 약관 내용 전문 (Full Text)
effective_date: 이 버전의 시행일


사용자 동의 기록 테이블
consent_id (PK)
user_id (FK, users 테이블 참조)
term_id (FK, terms_of_service 테이블 참조)
agreed_at: 동의한 시각 (Timestamp)
ip_address: 동의 당시 IP 주소 (법적 증거력 강화)








// src/models/AccessLog.js 로그인 기록 스키마
import mongoose from 'mongoose';
const { Schema, model } = mongoose;

const accessLogSchema = new Schema({
    // 1. 누가 (Who)
    user: {
        type: Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true // 유저별 접속 기록 조회용 인덱스
    },

    // 2. 어디서 (Where - IP)
    ip: {
        type: String,
        required: true
    },

    // 3. 무엇을 (What - Action) ⭐ [추가됨]
    action: {
        type: String,
        enum: [
            'login',             // 로그인 성공
            'socket_connect',    // 소켓 연결 (채팅방 입장 등)
            'socket_reconnect',  // 소켓 재연결 (새로고침, 네트워크 변경)
        ],
        required: true
    },

    // 4. 어떤 기기로 (Device) ⭐ [추가됨]
    userAgent: {
        type: String,
        required: false // 가끔 헤더에 없을 수도 있음
    },

    // 6. 상태 (Status) - 로그인 실패/성공 여부 (선택사항)
    status: {
        type: String,
        enum: ['success', 'fail'],
        default: 'success'
    },

    // 7. 언제 (When)
    createdAt: {
        type: Date,
        default: Date.now
    }
});



// ✅ 법적 의무 자동화: 3개월(90일) 뒤 자동 삭제 (TTL 인덱스)
accessLogSchema.index({ createdAt: 1 }, { expireAfterSeconds: 7776000 });

// ✅ 관리자 페이지용 검색 인덱스 (IP 추적, 날짜별 조회)
accessLogSchema.index({ ip: 1 });
accessLogSchema.index({ user: 1, createdAt: -1 });

export const AccessLog = model('AccessLog', accessLogSchema);


새로고침을 할 때마다 무조건 Insert를 해버리면,
 유저가 F5를 연타하거나 네트워크가 불안정할 때 불필요한 로그가 폭발적으로 쌓여 DB가 낭비됩니다.

따라서 "스마트 로깅(Smart Logging)" 전략이 필요합니다. 핵심은 **"마지막으로 기록된 로그와 비교해서,
 변동 사항이 있을 때만 남긴다"**입니다.


1. 로그를 남기는 기준 (Filter Logic)새로고침이나 소켓 재연결 요청이 들어왔을 때, DB에 바로 저장하지 말고 **먼저 조회(Check)**를 한번 해야 합니다.
상황기존 마지막 로그와 비교저장 여부이유새로고침 (F5)IP가 동일함❌ 저장 안 함1초 전 기록과 똑같은데 굳이 남길 필요 없음와이파이
→ LTEIP가 다름⭕ 저장함네트워크가 바뀌었으므로 추적을 위해 기록 필수1시간 뒤 접속IP는 같지만 시간 차이가 큼⭕ 저장함"아직 활동 중"이라는 생존 신고용 (세션 연장)리프레시 토큰IP가 동일함❌
저장 안 함내부적인 토큰 갱신일 뿐, 유저의 위치 변화 없음2. 구현 코드: "중복 로그 방지" 미들웨어이 함수를 만들어두고 로그인, 소켓 연결, 토큰 재발급 로직에서 공통으로 사용하세요.
핵심 로직:이 유저의 가장 최신 로그를 하나 가져온다.지금 접속한 IP와 비교한다.IP가 다르거나, 마지막 로그로부터 1시간 이상 지났으면 새로 저장한다.그렇지 않으면 무시한다.JavaScript// src/utils/logUtils.js


정리
- 최초로그인시 ip, 접속기기, 소켓아이디 등 기록
- 소캣아이디가 변경된다고 기록하는건 X
- ip가 바뀐다면 로그 기록하기 (공인 사설 다름 제미나이 한테 물어보기)
- 아이피 그대로인데 브라우저, 기기정보가 바뀐다면 기록하기
- 로그인이 되어있다면 1시간 주기로 ip로그와 브라우저 등 기록

==========================================================================
💻 기술적 팩트 체크
1. 192.168.x.x (사설 IP)
이건 PC방 공유기가 자기들끼리 쓰려고 만든 가짜 주소입니다.

사용자님의 **웹 서버(Node.js)**는 이 주소를 죽었다 깨어나도 알 수 없습니다. (요청 헤더에 안 실려 옴)

따라서 자리를 옮겨서 이 숫자가 아무리 바뀌어도, 서버는 변화를 감지할 수 없습니다.

2. 211.55.x.x (공인 IP)
이건 KT/SKT/LG가 부여한 진짜 주소입니다.

서버는 이 주소를 봅니다.

만약 10.1에서 10.2로 바뀌었다면, 그건 단순한 옆자리가 아니라 아예 다른 인터넷 회선을 쓰는 자리이거나 다른 장소일 가능성이 큽니다.

따라서 무조건 기록해야 합니다.

🎯 요약
PC방 옆자리 이동 (192... 변경): 서버는 **"IP 안 바뀜"**으로 인식합니다. (로그 안 쌓임, DB 절약됨)

공인 IP 변경 (211... 변경): 서버는 **"IP 바뀜"**으로 인식합니다. (로그 쌓임)

결론: 개발자는 고민할 필요 없이 "서버에 찍히는 IP 문자열이 다르면 무조건 저장한다" 로직만 쓰시면 됩니다. (PC방 옆자리 이동 같은 건 서버가 알아서 무시하게 됩니다.)






import { AccessLog } from '../models/AccessLog.js';

/**
 * 스마트 로그 저장 함수
 * - IP가 변경되었거나, 마지막 로그 이후 일정 시간이 지났을 때만 저장
 */
export const checkAndLogAccess = async (userId, currentIp, action, userAgent) => {
    try {
        // 1. 해당 유저의 가장 최근 로그 1개 조회
        const lastLog = await AccessLog.findOne({ user: userId })
                                       .sort({ createdAt: -1 });

        // 2. 저장 여부 판단
        let shouldSave = false;

        if (!lastLog) {
            // 로그가 하나도 없으면 무조건 저장 (첫 접속)
            shouldSave = true;
        } else {
            const isIpChanged = lastLog.ip !== currentIp;

            // 마지막 로그로부터 지난 시간 (단위: 분)
            const timeDiff = (Date.now() - new Date(lastLog.createdAt).getTime()) / 1000 / 60;
            const isTimeExpired = timeDiff > 60; // 60분(1시간) 지났으면 다시 기록

            if (isIpChanged || isTimeExpired) {
                shouldSave = true;
            }
        }

        // 3. 조건 충족 시에만 DB 저장
        if (shouldSave) {
            await AccessLog.create({
                user: userId,
                ip: currentIp,
                action: action, // 'login', 'socket_reconnect', 'token_refresh' 등
                userAgent: userAgent
            });
            // console.log(`📝 [Log Saved] User: ${userId}, IP: ${currentIp}, Action: ${action}`);
        } else {
            // console.log(`🚫 [Log Skipped] 중복된 접속 또는 짧은 시간 내 재접속`);
        }

    } catch (error) {
        console.error('로그 저장 중 오류 발생 (무시됨):', error);
        // 로그 저장이 실패했다고 메인 로직이 멈추면 안 되므로 에러는 찍고 넘어감
    }
};
3. 적용 예시① 소켓 연결 (Socket.io)새로고침을 하면 소켓이 끊겼다 다시 붙는데, 이때 위 함수를 쓰면 IP가 같을 경우 무시되므로 DB 부하가 없습니다.JavaScript// socket.js
io.on('connection', async (socket) => {
    const userId = socket.user._id;
    const userIp = socket.handshake.address; // 혹은 헤더에서 추출
    const userAgent = socket.handshake.headers['user-agent'];

    // 스마트 로깅 함수 호출 (await 안 걸어도 됨 - 비동기 처리)
    checkAndLogAccess(userId, userIp, 'socket_connect', userAgent);

    // ... 채팅 로직 ...
});
② 리프레시 토큰 갱신 (API)액세스 토큰이 만료되어 클라이언트가 /refresh API를 호출할 때도 똑같이 적용합니다.JavaScript// authController.js (리프레시 토큰 처리 함수)
export const refreshToken = async (req, res) => {
    // ... 토큰 검증 및 재발급 로직 ...

    const userIp = req.ip;
    const userAgent = req.headers['user-agent'];

    // 여기서도 호출! (IP가 안 바뀌었으면 저장 안 함)
    checkAndLogAccess(user._id, userIp, 'token_refresh', userAgent);

    res.json({ accessToken: newAccessToken });
};
🎯 요약새로고침 때마다 저장? → NO. (비효율적)리프레시 토큰 때마다 저장?
 → NO. (비효율적)언제 저장? → "IP가 바뀌었거나" 또는 **"마지막 기록 후 1시간이 지났을 때"**만 저장하세요.
 방법: 위에 짜드린 checkAndLogAccess 함수를 미들웨어처럼 사용하시면 DB 용량도 아끼고 법적 증거 능력도 챙길 수 있습니다.








